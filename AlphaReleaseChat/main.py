# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'Main.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import QtCore, QtGui, QtWidgets, Qt
from PyQt5.QtWidgets import QToolBar, QAction, QApplication
from PyQt5.QtGui import QIcon, QKeySequence
from PyQt5.QtCore import QSize, QThread, pyqtSignal, QObject, QEvent

import os
import datetime   
import pyglet      
from plyer import notification 
from about import Ui_DialogAbout
from signin import Ui_DialogSignIn
from settings import Ui_DialogSettings
from anyerror import Ui_DialogErrorAny
from errorSignIn import Ui_DialogSignInChat
from errorLen import Ui_DialogLenght
from signinconnect import Ui_DialogConnectTo

import socket
import sys

global setting      #настрйка уведомлений
setting = ''

#Внимание! программа тестировалась  на разрешении 1366 на 768, поэтому возможны графические недочёты на других разрешениях

checkdirCONNEVTS = os.path.exists('connects')
if checkdirCONNEVTS == False:       #если программа запущена впервые
    try:
        os.mkdir('connects')
        ipFile =  open('connects/currentConnectIp', 'w')
        ipFile.write('127.0.0.1')                           #Записывает ip сервера, который установлен по умолчанию
        ipFile.close()

        portFile = open('connects/currentConnectPort', 'w')
        portFile.write('55555')                             #Записывает порт сервера, который установлен по умолчанию
        portFile.close()
        

        ipFileR =  open('connects/currentConnectIp', 'r')
        host = str(ipFileR.read())
        ipFileR.close()

        portFileR = open('connects/currentConnectPort', 'r')
        port = int(portFileR.read())
        portFileR.close()
    except:
        pass


else:

    try:

        ipFile =  open('connects/currentConnectIp', 'r')
        host = str(ipFile.read())
        ipFile.close()

        portFile = open('connects/currentConnectPort', 'r')
        port = int(portFile.read())
        portFile.close()

    except:
        pass

global platform     #платформа
platform = ''

global globalmessage       #перхват сообщения для локального сохранения
globalmessage = ''

global notifOld             #старое имя для переименования
notifOld = ''

global writeMessage     #блокировка кнопки для отправки, чтобы пользователь не отравлял сообщения пока не подключился к серверу
writeMessage = False

global canSend          #проверка способоности отправки(используеться при переименновании и функциях, которые отправляют уведомления на сервер(о заходе или выходе))
canSend = False

global oldName          #старое имя пользователя используеться при переименовании
oldName = ''

global newName          #новое имя пользователя используеться при переименновании
newName = ''

global nameBlock        #если пользователь переименовался до того как войдёт в сеть, становиться true и отправляет уведомление при подключении к серверу         
nameBlock = None


try:
    client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)      #создание клинта

    client.connect((host, port))                                    #соеденение с сервером
except:                                                             #если не получилось соедениться с сервером, вылетит диолог соединения
        app = QtWidgets.QApplication(sys.argv)
        DialogConnectTo = QtWidgets.QDialog()
        ui = Ui_DialogConnectTo()
        ui.setupUi(DialogConnectTo)
        DialogConnectTo.show()
        sys.exit(app.exec_())


class Ui_MainWindow(object):                                    #основное окно

    def copyActionRead(self):                                   #функция контекстного меню копировать виджета для чтения сообщений
        self.textEditReadMessages.copy()

    def copyAction(self):                                       #функция контекстного меню копировать для написания сообщения
        self.textEditWriteMessage.copy()
    
    def pasteAction(self):                                      #функция контекстного меню вставить
        self.textEditWriteMessage.paste()
    
    def cutAction(self):                                        #функция контекстного меню вырезать
        self.textEditWriteMessage.cut()
    
    def selectAction(self):                                     #функция контекстного меню выбрать всё
        self.textEditWriteMessage.selectAll()
    
    def undo(self):                                             #функция контекстного меню отменить
        self.textEditWriteMessage.undo()

    def redo(self):                                             #функция контекстного меню повторить
        self.textEditWriteMessage.redo()

    def settingsFunc(self):                                     #функция открытия окна настроек
        global canSend
        global oldName
        global newName
        global nameBlock
        global notifOld
################################################################################
        Form_Settings = QtWidgets.QDialog()         #открытие окна настроек
        settings = Ui_DialogSettings()
        settings.setupUi(Form_Settings)
        Form_Settings.exec_()
############################################################################
        checkdirtemp = os.path.exists('users/temp')         #проверка существования файла с старым именем
        if checkdirtemp == True:                            #если оно есть
            if canSend == True:                             #если соеденён с сервером
                #################################################################
                oldNamef = open('users/temp', "r")          #чтение имён
                oldNamel = str(oldNamef.read())
                oldNamef.close()
                userNow = open('users/current', 'r')
                nickname = str(userNow.read())
                userNow.close()
                notifOld = oldNamel
                ###################################################################
                notification = f"<html><head/><body><table width = '100%' cellpadding='3' cellspacing='0'><tr><td valign='center' align = 'center'><font color = '#ffffff'><b>{oldNamel}</b> изменил имя на <b>{nickname}</b></font></tr></td></table><br></body></html>"
                client.send(notification.encode('utf-8')) #отправка уведомления
                os.remove('users/temp')             #удаление файла со старым именем

            elif canSend == False:                  #если не соединён
                nameBlock = True                    #"триггер" для кнопки подключения, который сразу отправляет уведомление о переименновании
                #####################################################################################
                oldNamef = open('users/temp', "r")
                oldName = str(oldNamef.read())              #передача имён
                oldNamef.close()
                userNow = open('users/current', 'r')
                newName = str(userNow.read())
                userNow.close()
                ###################################################################################
                os.remove('users/temp')             #удаление старого имени


    def aboutFunc(self):                        #функция диолога "о программе"
        self.Form_About = QtWidgets.QDialog()
        self.about = Ui_DialogAbout()
        self.about.setupUi(self.Form_About)
        self.Form_About.exec_()

######################### Требует доработки для уведомлений в чат при обычном закрытии#####################################
    def exitFunc(self, event):                  #функция для кнопки выхода
        global canSend
        if canSend == True:                     
            userNow = open('users/current', 'r')
            newName = str(userNow.read())
            userNow.close()
            notification = f"<html><head/><body><table width = '100%' cellpadding='3' cellspacing='0'><tr><td valign='center' align = 'center'><font color = '#ffffff'><b>{newName}</b> покинул чат</font></tr></td></table><br></body></html>"
            client.send(notification.encode('utf-8'))

            QApplication.quit()
        else:
            QApplication.quit()
#####################################################################################

    def platformCheck(self):        #проверка платформы
        global platform
        platform = str(sys.platform)



    def _createContextMenuEdit(self):               #функция создания контекстного меню для написания сообщения
        menu = QtWidgets.QMenu()                    #меню
        menu.setStyleSheet("QMenu{background-color: rgb(56, 37, 0);\n color: White;}"               #стиль
        "QMenu::item:selected{background-color: rgb(46, 27, 0);\n color: White;}")

        copyAction = menu.addAction(QIcon('icon/ico_copy.png'), "Копировать")                       #создание действия
        pasteAction = menu.addAction(QIcon('icon/ico_paste.png'), "Вставить")                       #создание действия
        cutAction = menu.addAction(QIcon('icon/ico_cut.png'), "Вырезать")                           #создание действия
        selectAction = menu.addAction(QIcon('icon/ico_selectAll.png'), "Выбрать всё")               #создание действия
        undo = menu.addAction(QIcon('icon/ico_undo.png'), "Отменить")                               #создание действия
        redo = menu.addAction(QIcon('icon/ico_redo.png'), "Повторить")                              #создание действия
        sendMessage = menu.addAction(QIcon('icon/ico_send_message.png'), "Отправить сообщение")     #создание действия
        

        copyAction.triggered.connect(self.copyAction)               #соединение действия с функцией
        pasteAction.triggered.connect(self.pasteAction)             #соединение действия с функцией
        cutAction.triggered.connect(self.cutAction)                 #соединение действия с функцией
        selectAction.triggered.connect(self.selectAction)           #соединение действия с функцией
        sendMessage.triggered.connect(self.sendMessage)             #соединение действия с функцией
        undo.triggered.connect(self.undo)                           #соединение действия с функцией
        redo.triggered.connect(self.redo)                           #соединение действия с функцией

        copyAction.setShortcut(QKeySequence.Copy)                   #объявление горячих клавиш
        pasteAction.setShortcut(QKeySequence.Paste)                 #объявление горячих клавиш
        cutAction.setShortcut(QKeySequence.Cut)                     #объявление горячих клавиш
        selectAction.setShortcut("Ctrl+A")                          #объявление горячих клавиш
        undo.setShortcut(QKeySequence.Undo)                         #объявление горячих клавиш
        redo.setShortcut(QKeySequence.Redo)                         #объявление горячих клавиш

        menu.exec_(QtGui.QCursor.pos())                             #отслеживание позиции курсора

    def _createContextMenuRead(self):               #создание контекстного меню для чтения сообщений
            menu = QtWidgets.QMenu()                #меню
            menu.setStyleSheet("QMenu{background-color: rgb(56, 37, 0);\n color: White;}"   #стиль
            "QMenu::item:selected{background-color: rgb(46, 27, 0);\n color: White;}")

            copyAction = menu.addAction(QIcon('icon/ico_copy.png'), "Копировать текст")     #создание действия

            copyAction.triggered.connect(self.copyActionRead)                               #соединение действия с функцией

            copyAction.setShortcut(QKeySequence.Copy)                                       #объявление горячих клавиш

            menu.exec_(QtGui.QCursor.pos())                                                 #отслеживание позиции курсора

    def _createToolBars(self):                                                  #создание тулбара
        
        menuToolBar = QToolBar("Menu")                          #тулбар
        MainWindow.addToolBar(QtCore.Qt.ToolBarArea.LeftToolBarArea, menuToolBar) #добавить тулбар
        menuToolBar.setMovable(False)       #запрет на перемещение

        menuToolBar.setToolButtonStyle(QtCore.Qt.ToolButtonTextUnderIcon)       #задание стиля кнопок (подпись под иконкой кнопки)
        menuToolBar.setStyleSheet("background-color: rgb(56, 37, 0);\n color: White; QToolTip {background-color: #533d00; color: white;}")  #стиль
        

        settingIco=QIcon("icon/ico_settings.png")   #иконка
        settingsAction = menuToolBar.addAction(settingIco, "Настройки")     #кнопка
        l = settingsAction.setToolTip(u"<html><head/><body><font color = 'black'>Настройки</font></body></html>")   #Стиль подсказки
        settingsAction.triggered.connect(self.settingsFunc)     #Соединение с функцией

        aboutIco=QIcon("icon/ico_about.png")        #иконка
        aboutAction = menuToolBar.addAction(aboutIco, "О программе")        #кнопка
        aboutAction.setToolTip(u"<html><head/><body><font color = 'black'>О программе</font></body></html>")    #Стиль подсказки
        aboutAction.triggered.connect(self.aboutFunc)           #Соединение с функцией

        exitIco=QIcon("icon/ico_exit.png")          #иконка
        exitAction = menuToolBar.addAction(exitIco, "Выход")                #кнопка
        exitAction.setToolTip(u"<html><head/><body><font color = 'black'>Выход</font></body></html>")   #Стиль подсказки
        exitAction.triggered.connect(self.exitFunc)             #Соединение с функцией

        settingsAction.setShortcut("Ctrl+P")            #горячие клавиши настройки
        aboutAction.setShortcut("Ctrl+I")               #горячие клавиши о программе


        menuToolBar.setIconSize(QSize(42,42))           #установка размера иконки кнопок
        

    def setupUi(self, MainWindow):                      #развёртка главного окна
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(800, 600)
        MainWindow.setWindowIcon(QtGui.QIcon("icon/ico_main.ico"))
        self.centralwidget = QtWidgets.QWidget(MainWindow)      #центральный "фрейм"

        self.centralwidget.setStyleSheet("background-color:#533d00")    #стиль
        self.centralwidget.setObjectName("centralwidget")
        self.verticalLayout = QtWidgets.QVBoxLayout(self.centralwidget)
        self.verticalLayout.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout.setSpacing(0)
        self.verticalLayout.setObjectName("verticalLayout")

        self.pushButtonConnect = QtWidgets.QPushButton(self.centralwidget)      #кнопка подключения к серверу
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.pushButtonConnect.sizePolicy().hasHeightForWidth())
        self.pushButtonConnect.setSizePolicy(sizePolicy)
        self.pushButtonConnect.setMinimumSize(QtCore.QSize(0, 46))
        self.pushButtonConnect.setMaximumSize(QtCore.QSize(16777215, 46))
        self.pushButtonConnect.setSizeIncrement(QtCore.QSize(0, 46))
        self.pushButtonConnect.setBaseSize(QtCore.QSize(0, 46))
        font = QtGui.QFont()
        font.setPointSize(12)
        self.pushButtonConnect.setFont(font)
        self.pushButtonConnect.setStyleSheet("QPushButton:!hover {background-color: rgb(61, 40, 0); color: white; text-align: center; font-size: 18px; border-style: outset; border-width: 0px;}\n"
"QPushButton:hover {background-color: rgb(88, 58, 0); color: white; text-align: center; border-style: outset; font-size: 18px; border-width: 0px;}")
        self.pushButtonConnect.setObjectName("pushButtonConnect")           #связка кнопки с функцией соединения

        self.verticalLayout.addWidget(self.pushButtonConnect)       

        self.pushButtonConnect.setText("Присоедениться к чату")                 #подпись кнопки

        self.pushButtonConnect.setIcon(QIcon('icon/ico_connect.png'))           #добавление иконки
        self.pushButtonConnect.setIconSize(QtCore.QSize(25,25))                 #размер иконки


        self.frameMessages = QtWidgets.QFrame(self.centralwidget)
        self.frameMessages.setFrameShape(QtWidgets.QFrame.StyledPanel)
        self.frameMessages.setFrameShadow(QtWidgets.QFrame.Raised)
        self.frameMessages.setObjectName("frameMessages")
        self.verticalLayout_2 = QtWidgets.QVBoxLayout(self.frameMessages)
        self.verticalLayout_2.setContentsMargins(9, 5, 9, 5)
        self.verticalLayout_2.setSpacing(5)
        self.verticalLayout_2.setObjectName("verticalLayout_2")
        self.textEditReadMessages = QtWidgets.QTextEdit(self.frameMessages)     #виджет для чтения сообщений(место где отображаються полученные сообщения)
        font = QtGui.QFont()
        font.setPointSize(12)
        self.textEditReadMessages.setFont(font)
        self.textEditReadMessages.setStyleSheet("border-style: outset;\n"
"border-width: 2px;\n"
"border-color: rgb(62, 41, 0);\n"
"border-radius: 15px;\n"
"color:White;")
        self.textEditReadMessages.setReadOnly(True)             #только для чтения
        self.textEditReadMessages.setObjectName("textEditReadMessages")
        self.verticalLayout_2.addWidget(self.textEditReadMessages)
        self.verticalLayout.addWidget(self.frameMessages)
        self.frameEditMessage = QtWidgets.QFrame(self.centralwidget)    #фрейм для "редактирования" и отправки сообщения
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.frameEditMessage.sizePolicy().hasHeightForWidth())
        self.frameEditMessage.setSizePolicy(sizePolicy)
        self.frameEditMessage.setStyleSheet("background:qlineargradient(spread:pad, x1:0.494, y1:0, x2:0.5, y2:1, stop:0 rgba(120, 86, 0, 255), stop:1 rgba(46, 35, 0, 255))")
        self.frameEditMessage.setFrameShape(QtWidgets.QFrame.StyledPanel)
        self.frameEditMessage.setFrameShadow(QtWidgets.QFrame.Raised)
        self.frameEditMessage.setObjectName("frameEditMessage")
        self.horizontalLayout = QtWidgets.QHBoxLayout(self.frameEditMessage)
        self.horizontalLayout.setObjectName("horizontalLayout")
        self.textEditWriteMessage = QtWidgets.QTextEdit(self.frameEditMessage)  #текстовое для написания сообщения
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.textEditWriteMessage.sizePolicy().hasHeightForWidth())
        self.textEditWriteMessage.setSizePolicy(sizePolicy)
        self.textEditWriteMessage.setStyleSheet("border-style: outset;\n"
"border-width: 2px;\n"
"border-color: rgb(62, 41, 0);\n"
"border-radius: 15px;\n"
"color:White;")
        self.textEditWriteMessage.setPlaceholderText("Написать сообщение...")   #добавление подсказки
        self.textEditWriteMessage.setObjectName("textEditWriteMessage")
        font = QtGui.QFont()
        font.setPointSize(11)
        self.textEditWriteMessage.setFont(font)
        self.horizontalLayout.addWidget(self.textEditWriteMessage)
        self.pushButtonSend = QtWidgets.QPushButton(self.frameEditMessage)      #кнопка для отправки сообщения
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.pushButtonSend.sizePolicy().hasHeightForWidth())
        self.pushButtonSend.setSizePolicy(sizePolicy)
        self.pushButtonSend.setMaximumSize(QtCore.QSize(55, 55))
        self.pushButtonSend.setObjectName("pushButtonSend")
        self.pushButtonSend.setStyleSheet("QPushButton {background-color: rgb(107, 71, 0);\ncolor: rgb(172, 115, 0);\nborder-style: outset;\nborder-width: 2px;\nborder-radius: 15px;\nborder-color: rgb(107, 71, 0);\npadding: 4px;\n}"
        "QPushButton:pressed {background-color: #382500;\ncolor: rgb(172, 115, 0);\nborder-style: outset;\nborder-width: 2px;\nborder-radius: 15px;\nborder-color: #241800;\npadding: 4px;\n}")
        self.pushButtonSend.setIcon(QtGui.QIcon('icon/ico_send.png'))
        self.pushButtonSend.setIconSize(QSize(25, 25))
        self.horizontalLayout.addWidget(self.pushButtonSend)
        self.verticalLayout.addWidget(self.frameEditMessage)
        MainWindow.setCentralWidget(self.centralwidget)
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)

        self.textEditWriteMessage.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)                 #разрешение на редпктирование контекстного меню виджета для чтения
        self.textEditWriteMessage.customContextMenuRequested.connect(self._createContextMenuEdit)   #привязка контекстного меню с виджитом для чтения

        self.textEditReadMessages.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)                 #разрешение на редактирование контекстного меню виджета для написания
        self.textEditReadMessages.customContextMenuRequested.connect(self._createContextMenuRead)   #привязка контекстного меню с виджитом для написания

        self.pushButtonSend.clicked.connect(self.sendMessage)               #соединение кнопки отправки сообщения с функцией отправки
        self.pushButtonSend.setShortcut("Ctrl+Return")                      #создание горячих клавиш для отправки сообщения

        self.pushButtonConnect.clicked.connect(self.connectPress)           #соединение кнопки соединение с сервером с функцией соединения

        #self.textEditReadMessages.textChanged.connect(self.saveMessage)
        self.textEditWriteMessage.textChanged.connect(self.styleSheetMess)
        self.platformCheck()



        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)
        checkdir = os.path.exists('users')          #проверка на количество входов(если пользователь запускает программу впервые папка users не будет существовать)
        

        
        checkdirout = os.path.exists('users/out')   #проверка на состаяние пользователя(если он вышел из "аккаунта")
        if checkdir == False or checkdirout == True:
            sys.exit()

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "PythonTCP [alpha-release]"))   #заголовок главного окна

        self._createToolBars()          #вызов функции создания тулбара

        checkdir = os.path.exists('users') 
        checkdirout = os.path.exists('users/out') 
        if checkdir == False or checkdirout == True:    #запуск окна входа если пользователь вышел или впервые запускает программу
#################################################################################
                Form_Signin = QtWidgets.QDialog()   #диалог входа в "аккаунт"
                signin = Ui_DialogSignIn()
                signin.setupUi(Form_Signin)
                Form_Signin.exec_()
#######################################################################
        else:
            pass            #сразу запустить главное окно

    
    def styleSheetMess(self):
        self.textEditReadMessages.setStyleSheet("border-style: outset;\n"
        "border-width: 2px;\n"
        "border-color: rgb(62, 41, 0);\n"
        "border-radius: 15px;\n"
        "color:White; \n"
        "font: 12pt \'MS Shell Dlg 2\';")
        font = QtGui.QFont()
        font.setBold(False)
        font.setItalic(False)
        font.setPointSize(12)
        self.textEditReadMessages.setFont(font)



    def saveMessage(self):      #сохранение истории сообщений
        global globalmessage
        currentNamef = open('users/current', 'r')   #чтение имени "войдённого" пользователя
        currentName = str(currentNamef.readline().rstrip('\n'))
        currentNamef.close()

        encodeCurrentName = currentName.encode()
        decodeCurrentName = encodeCurrentName.decode('utf-8')   #конвертирование имени, для исправление ошибок с кириллицей

        mess = globalmessage
        encodeMess = mess.encode()
        decodeMess = encodeMess.decode('utf-8')

        
        check1 = os.path.exists(f'users/message')               #проверка существования папки с "историей"
        check2 = os.path.exists(f'users/message/{decodeCurrentName}')   #проверка существования файла истории

        if check1 == False:
            os.mkdir('users/message')               #если папки не существует, она создаётся
        if check2 == False:    
            os.mkdir(f'users/message/{decodeCurrentName}')      #если не существует файла с историей, он создаётся
        messageText = open(f'users/message/{decodeCurrentName}/Messages.txt', "a+")     #иначе дополняется
        messageText.write(f'{decodeMess}')
        messageText.close()


            
    
    def connectPress(self):     #функция соединения
        global writeMessage
        global canSend
        global oldName
        global newName
        global nameBlock

        if canSend == False and nameBlock == None:  #если пользователь подключился, разрешает отпровлять уведомления
            canSend = True
        elif canSend == False and nameBlock == True:    #иначе разрешает, но отправляет через себя

            canSend = True
            notification = str(f"<html><head/><body><table width = '100%' cellpadding='3' cellspacing='0'><tr><td valign='center' align = 'center'><font color = '#ffffff'><b>{oldName}</b> изменил имя на <b>{newName}</b></font></tr></td></table><br></body></html>")
            client.send(notification.encode('utf-8'))

        try:
            self.pushButtonConnect.setVisible(False)    #скрывает кнопку

            writeMessage = True                         #разрешает отправку сообщений

            self.obj = Recieve(client)                  #создаёт поток для слушания сообщений
            self.obj.signal.connect(self.show_message)  #соеденяет его с функцией показа сообщений и передаёт свои данные через эту функцию, так как напримую другой поток не может взаимодействовать с другим
            self.obj.start()                            #запускает поток для слушания сообщений

            nicknameFile = open('users/current', 'r')   #чтение ника пользователя
            nickName = nicknameFile.readline().rstrip('\n')
            nicknameFile.close()

            message = f"<html><head/><body><p><table width = '100%' cellpadding='3' cellspacing='0'><tr><td valign='center' align = 'center'><font color = '#ffffff'><b>{nickName}</b> присоеденился к чату</font></tr></td></table></p><p></p></body></html>" #уведомление о присоеденении пользователя
            client.send(message.encode('utf-8'))    #отправка уведомления
        except:
            self.pushButtonConnect.setVisible(True) #при ошибки снова становиться видимым
            writeMessage = False    #запрещает отправку сообщений


    def sendMessage(self):          #функция отправки сообщения
        global writeMessage
        if writeMessage == True:    #если разрешенна отправка сообщений
            nicknameFile = open('users/current', 'r')       #ник
            nickName = nicknameFile.readline().rstrip('\n')
            nicknameFile.close()

            messageText = str(self.textEditWriteMessage.toPlainText())      #сообщение
            self.textEditWriteMessage.setText('')

            time = str(datetime.datetime.now().strftime("%H:%M %d.%m.%Y"))  #получение даты и времени

            lenghtmessage = len(messageText)    #проверка длинны сообщения

            if messageText != '':           #если сообщение не пустое
                
                if lenghtmessage <= 468:    #и длинна меньше или равна 468 символам

                    style = "<html><head><style>td {padding-left: 10px; padding-right: 10px;} .message {padding-left: 20px; padding-right: 10px; padding-bottom: 9px}</style>" #стиль таблицы для отображения сообщения
                    message = f"{style}<head/><body><table width = '100%' cellpadding='3' cellspacing='0'><tr><td valign='top' bgcolor='#5c4200' width = 86%><b><font color = #bda980>{nickName}</b></font></td><td valign='top' bgcolor='#5c4200' width = 14% align = 'right'><font color = #bda980 size = 5px>{time}</td></font><tr><td class = 'message' valign='top' bgcolor='#5c4200' width = 100% colspan= '2'>{messageText}</td></tr></table><br></body></html>" # шаблон для сообщения

                    client.send(message.encode('utf-8'))    #отправка сообщения
                else:
##########################################################################
                    Form_Len = QtWidgets.QDialog()  #диолог о том что сообщение больше 468 символов
                    lener = Ui_DialogLenght()
                    lener.setupUi(Form_Len)
                    Form_Len.exec_() 
###################################################################

        
        else:                                   #если пользователь ещё не присоеденился к чату
#######################################################################################
            Form_SigninCH = QtWidgets.QDialog()
            signinCH = Ui_DialogSignInChat()        #диалог с просьбой к подключению
            signinCH.setupUi(Form_SigninCH)
            Form_SigninCH.exec_() 
##################################################################

    def show_message(self, message):            #функция отображения сообщения
        global notifOld
        global globalmessage

        self.textEditReadMessages.append(message)       #отображение полученного сообщения в виджет
        globalmessage = message

        nicknameFile = open('users/current', 'r')       #ник
        nickName = nicknameFile.readline().rstrip('\n')
        nicknameFile.close()

        self.saveMessage()

        ############################################# Фильтр сообщений для уведомлений всех, кроме отправителя #################################
        notSign = f"<html><head/><body><p><table width = '100%' cellpadding='3' cellspacing='0'><tr><td valign='center' align = 'center'><font color = '#ffffff'><b>{nickName}</b> присоеденился к чату</font></tr></td></table></p><p></p></body></html>"
        rename = f"<html><head/><body><table width = '100%' cellpadding='3' cellspacing='0'><tr><td valign='center' align = 'center'><font color = '#ffffff'><b>{notifOld}</b> изменил имя на"

        checkm = message.find(f"<head/><body><table width = '100%' cellpadding='3' cellspacing='0'><tr><td valign='top' bgcolor='#5c4200' width = 86%><b><font color = #bda980>{nickName}</b></font></td>")
        checkК = message.find(rename)

        if message == notSign:
            pass
        elif checkК == 0:
            pass
        elif checkm == -1:
            ####################################### звук и уведоление ######################################
            music = pyglet.resource.media('Icon/not.wav')
            music.play()
            self.showNotification()

    def showNotification(self):             #отображение уведомлений
        global platform
        global setting
        noticheck = os.path.exists('users/settingFile')
        if noticheck == False:
            setting = False
        else:
            settingFile=open('users/settingFile', 'r+')
            noti = settingFile.readline().rstrip()
            settingFile.close()

            if noti == 'Notification: False':
                setting = False 
            elif noti == 'Notification: True':
                setting = True

        if platform == 'win32' and setting == True:
            try:
                notification.notify(title='Сообщение', message='У вас есть сообщения', app_name='PythonTCP', app_icon=os.path.abspath('Icon/ico_ok.ico'))
            except:
                pass
        if platform == "Darwin" and setting == True:
            try:
                command = '''
                osascript -e 'display notification "У вас есть сообщения" with title "Чат"'
                '''
            except:
                pass
        elif platform == "Linux" and setting == True:
            try:
                command = f'''
                notify-send "Чат" "У вас есть сообщения"
                '''
            except:
                pass


class Recieve(QThread):                         #класс прослушки новых сообщений
    signal = pyqtSignal(str)                    #сигнал триггерующий функцию

    def __init__(self, client):                 #инициализация
        super(Recieve, self).__init__()
        self.client = client
        

    def run(self):                              #запуск функции потока
        while True:
            self.recieveMessages()

    def recieveMessages(self):
        try:
            message = client.recv(1042).decode('utf-8') #слушание и дешифровка сообщения
            
            self.signal.emit(message)   #триггер сигнала

        except:             #при ошибке
####################################################################
            Form_Any = QtWidgets.QDialog()
            anyE = Ui_DialogErrorAny()      #диалог ошибка
            anyE.setupUi(Form_Any)
            Form_Any.exec_()
##############################################################
            
            client.close()      #завершение клиента







if __name__ == "__main__":
    
    ui = Ui_MainWindow()
    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    ui.setupUi(MainWindow)
    MainWindow.show()
    sys.exit(app.exec_())